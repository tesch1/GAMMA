#########################################################################
#                                                                       #
#        GAMMA Primal Makefile: Borland BC++ ==> (Py)GAMMA Library	#
#                                                                       #
# This is a primitive hand made Makefile to explicitly show how one     #
# builds and uses GAMMA as either a static library or DLL and how one	#
# builds and uses PyGAMMA. It assumes that one is using the Borland C++	#
# (free!) compiler on the command line & Borland make. At least,	#
# the binaries will be placed in a Borland related directory. So, run	#
# this makefile from a DOS/Windows command shell so bcc, make, etc. are #
# from Borland (assuming you've set up the Windows environment properly #
# to use the compiler). As for PyGAMMA, one must have Python (Windows)	#
# as well as Boost.Python on the system.				#
#                                                                       #
# --------------------------------------------------------------------- #
#                                                                       #
#                             Quick Info                                #
#                                                                       #
#  1. Type "make" to build GAMMA static library. 		  	#
#  2. Type "make demo" to compile and run the GAMMA demo program(s).    #
#  3. Type "make test" to compile and run the GAMMA test program(s).    #
#  4. Type "make clean" to remove all object files.			#
#  5. Type "make distclean" to remove all object files libraries, exes.	#
#  6. The sources are assumed in SRCDIR == ..\..\src			#
#  7. The object are be produced in BINDIR ==  ..\..\i686-pc-borland	#
#  8. The library files are produced in BINDIR == ..\..\i686-pc-borland	#
#  9. Any executable files (test,demo) are produced in this directory.	#
# 10. The important static library file is libgamma.a 			#
# 11. The important DLL library files are gamma.dll and libgamma.dll.a	#
# 12. The important PyGMAMA DLL library file is pygamma.dll.		#
# 13. Produces the following: a.) libgamma.a - The GAMMA static library	#
#			      b.) gamma.dll  - The GAMMA DLL		#
#			      c.) libgamma.dll.a - GAMMA imports lib.   #
#                             d.) pygamma.dll - PyGAMMA DLL             #
#                             e.) DemoGAMMA.exe - The demo program	#
#                             f.) TestGAMMA.exe - The test program	#
#                                                                       #
# --------------------------------------------------------------------- #
#                                                                       #
#                                 Notes					#
#                                                                       #
# This is NOT a standalone makefile. It includes an additional file	#
# ..\..\make\MakeMods which is part of standard GAMMA. This latter file #
# defines which files are part of the GAMMA source codes. Changes in    #
# MakeMods will evoke changes in the build herein.                      #
#									#
# all:									#
# make all: These both run the default target all (first target). It    #
#           will compile all source codes in GAMMA as defined in file	#
#           MakeMods into object files. It will then take the object	#
#           files and convert them into a static library named		#
#           libgamma.a. These same object files will then be combined	#
#           into a dynamic library (DLL) with its assocatied imports    #
#           library, gamma.dll and libgamma.dll.a respectively. If we   #
#           are able to find Python and Boost.Python, then the PyGAMMA  #
#           DLL is also built, pygamma.dll. All libraries and object	#
#           files will be made in the directory specified by BINDIR.    #
#									#
# make clean: This will delete all object files from any earlier build. #
#             It is important to run make clean since the object files  #
#             can use lots of disk space as well as interfere with      #
#             other GAMMA builds (not part of this Makefile)		#
#									#
# make demo : This will build and run a set of programs that demo the   #
#             the modules provided with GAMMA.				#
#                                                                       #
# make test: This will build and run a set of programs that test the	#
#             the modules provided with GAMMA.				#
#                                                                       #
#########################################################################


#########################################################################
#                                                                       #
#                    Borland Directory and Tools 			#
#                                                                       #
# BCDIR       = Borland compiler installation directory                 #
#                                                                       #
# Note that -P tells the compiler to force the compilation to use C++   #
# which is needed because Borland likes .cpp rather than .cc for its    #
# code files. The -c flag indicates one should make an object file      #
# rather than an executable (.obj not .exe)                             #
#                                                                       #
#########################################################################

BCDIR      = C:\Borland\BCC55
IMPLIB     = $(BCDIR)\bin\Implib
ILINK32    = $(BCDIR)\bin\ILink32
TLIB       = $(BCDIR)\bin\TLib
BRC32      = $(BCDIR)\bin\Brc32
TASM32     = $(BCDIR)\bin\Tasm32
CC         = $(BCDIR)\bin\BCC32
BCLEAN     = $(BCDIR)\bin\Bclean
L_FLAGS    = -x -c -v -aa -Tpd -Gi
BCC32RTLIB = cw32
RTLIB      = $(BCC32RTLIB).lib

#########################################################################
#                                                                       #
#                Semi-Standard Gnuish Makefile Variables                #
#									#
# CXX         = C++ compiler (used in default compiler rules)		#
# CPPFLAGS    = C preprocessor flags (used in default C/C++ rules)	#
# CXXFLAGS    = C++ compilation flags (used in default C++ builds)	#
# INCLUDES    = Header include directory (used in C++ compilations)     #
#									#
# Note that -P tells the compiler to force the compilation to use C++   #
# which is needed because Borland likes .cpp rather than .cc for its    #
# code files. The -c flag indicates one should make an object file      #
# rather than an executable (.obj not .exe)                             #
#									#
#########################################################################

CXX      = bcc32
CPPFLAGS = -P -c
CXXFLAGS =
DEBUG    = -g #-O2

#########################################################################
#                                                                       #
#                  Names Of Various Targets To Build                    #
#                                                                       #
# These names are associated with the library we plan to build.         #
#                                                                       #
# Static Library Variables                                              #
# ========================                                              #
# LIB_NAME    = Name of library to be generated/targeted.  (libgamma.a) #
#                                                                       #
# Dynamic Library (DLL) Variables                                       #
# ===============================                                       #
# DLL_NAME    = Name of DLL to be generated/targeted.      (gamma.dll)  #
# DLL_EXP_LIB = Name of exports library generated.    (libgamma.dll.a)  #
# DLL_EXP_DEF = Name of definiton file to use.             (gamma.def)  #
#                                                                       #
# PyGAMMA Dynamic Library (DLL) Variables                               #
# =======================================                               #
# PYG_NAME    = Name of PyGAMAM DLL to be generated       (pygamma.dll) #
# PYG_EXP_LIB = Name of exports library generated.   (libpygamma.dll.a) #
# PYINCDIR    = Header include directory for Python                     #
# PYLIBDIR    = Library include directory for Python                    #
# PYLIBDIR2   = Library include directory for Python                    #
# BOOSTINCDIR = Header include directory for Boost.Python               #
# BOOSTLIBDIR = Library include directory for Boost.Python              #
#                                                                       #
#########################################################################

LIB_NAME    = libgamma.a

DLL_NAME    = gamma.dll
DLL_EXP_LIB = libgamma.dll.a
DLL_EXP_DEF = gamma.def

PYG_NAME    = pygamma.dll
PYG_EXP_LIB = libpygamma.dll.a
#PYINCDIR    = C:\cygwin\usr\include\python2.2
#PYLIBDIR    = C:\cygwin\lib\python2.2
#PYDLLDIR    = C:\cygwin\lib\python2.2
#PYLIB2DIR   = C:\cygwin\lib\python2.2\config
#BOOSTINCDIR = "C:\Program Files\Boost\boost_1_29_0"
#BOOSTLIBDIR = "C:\Program Files\Boost\boost_1_29_0\libs\python\build\bin\boost_python.dll\gcc\release\inlining-on\runtim e-link-dynamic"


#########################################################################
#                                                                       #
#                       Gamma Related Variables                         #
#                                                                       #
#                                                                       #
# These variables are used to specify the GAMMA sources. Exactly what   #
# sources are associated with any one GAMMA module is contained in the  #
# external makefile MakeMods. From these we can construct the names of  #
# module source files and object files. These are directory specific.   #
#                                                                       #
# MakeMods    = File listing all current GAMMA source files.            #
# SRCDIR      = Base directory of GAMMA source codes.                   #
# BINDIR      = Base directory of Cygwin binaries.                      #
# LIB_SRCS    = All code files to be put into the GAMMA static library. #
# LIB_OBJS    = All object files to be put in the GAMMA static library. #
# DLL_SRCS    = All code files to be put into the GAMMA DLL.            #
# DLL_OBJS    = All object files to be put in the GAMMA DLL.            #
#                                                                       #
# The variable ALLCCFILES should contain all GAMMA source .cc files.    #
# The variable ALLOFILES should contain all GAMMA object .o files.      #
# The source file names will have the source sub-directory as a prefix. #
#     but not the full path relative to this directory.                 #
#                                                                       #
# The included makefile supplies NO targets or rules of any kind.       #
#                                                                       #
# Note: The Borland "make" program cannot handle addsuffix & addprefix  #
#       commands in the same fashion that GNU make does. This forces us #
#       to 1.) use a different method of specifying our file names, and #
#       2.) not rely on the Makefile ..\..\make\Makefile to accomplish  #
#       setting our file names herein. Since it is that very same file  #
#       that defines what GAMMA is, we have a sore spot because the     #
#       files to be used in this build then have to be maintained by    #
#       hand because the Borland one wi 
#                                                                       #
#                                                                       #
#########################################################################

!include "MakeMods"
SRCDIR   =  ..\..\src
BINDIR   = ..\..\i686-pc-borland
INCLUDES = ${SRCDIR}

.path.cc  = ${SRCDIR}
.path.obj = ${BINDIR}

#            Specify How To Compile Object Files From Source Files

.suffixes: .cc

MYDEF = anything
MYDEFO = $(addsuffix .o, $(MYDEF))

LIB_OBJS = ${BASICS_OBJ} ${MATRIX_OBJ} ${HSPACE_OBJ} ${LEVEL1_OBJ} \
	   ${LSPACE_OBJ} ${LEVEL2_OBJ}
DLL_OBJS = ${BASICS_OBJ}
LIB_A    = ${BASICS_A} ${MATRIX_A} ${HSPACE_A} ${LEVEL1_A} \
           ${LSPACE_A} ${LEVEL2_A}

LIB_SRCS = $(ALLCCFILES)
#LIB_OBJS = $(addsuffix .o, $(addprefix $(BINDIR)\, $(ALLFILES)))

DLL_SRCS = $(ALLCCFILES)
#DLL_OBJS = $(addsuffix .o, $(addprefix $(BINDIR)\, $(ALLFILES)))

PYG_SRCS =  $(ALLCCFILES)
PYG_SRCS += $(addsuffix .cc, $(addprefix $(SRCDIR)\, PyGAMMAIF))
PYG_OBJS =  $(addsuffix .po, $(addprefix $(BINDIR)\, $(ALLFILES)))
PYG_OBJS += $(addsuffix .po, $(addprefix $(BINDIR)\, PyGAMMAIF))


#########################################################################
#                                                                       #
#                           GAMMA Module Directories                    #
#                                                                       #
# These definitions are required for the pattern rules (later in this   #
# file) that dictate how source code is compiled. Since we like to keep #
# GAMMA code in several different subdirectories yet compile these into #
# object code in the same directory, these defintions are required to   #
# link specific source code directory names to the single directory we  #
# use for binary output (BINDIR).                                       #
#                                                                       #
#########################################################################

BASICS    = Basics
MATRIX    = Matrix
HSPACE    = HSLib
LEVEL1    = Level1
LSPACE    = LSLib
LEVEL2    = Level2
BLOCH     = Bloch
GAMIO     = GamIO
BWR       = WBR
PULSES    = Pulses
INTRANK2  = IntRank2
FLOQUET   = Floquet
GRADIENTS = Gradients
MULTISYS  = MultiSys
ESRLIB    = ESRLib
DEPREC    = Deprecated
TESTING   = Testing

#########################################################################
#                                                                       #
#               Build GAMMA Static Library Pattern Rules                #
#                                                                       #
# These rules specify how we build object file (*.obj) from C++ code    #
# files (*.cc). Borland make has a built in implicit pattern rule to do #
# a similar task:                                                       #
#                                                                       #
# .cpp.obj:                                                             #
#    bcc32 -c -ncobj $<                                                 #
#                                                                       #
# But that does not suffice for good reasons. First, GAMMA source files #
# reside in module directories off of the source directory SRCDIR.      #
# Second, we want all the object files to be built in the binaries      #
# directory, BINDIR. Thus we must build ${BINDIR}\*.obj from code files #
# ${SRCDIR}\${MODDIR}\*.cc. The main GAMMA  makefile handles this by    #
# recursing through each module directory and letting it decide how to  #
# build itself. Here we will define a rule for each module directory.   #
# Another reason is that since we use .cc rather than .cpp (preferred   #
# by Borland) for our C++ source file suffix, we need -P set as a flag  #
# on the compiler line to force a C++ compilation on a .cc file.        #
#                                                                       #
# For Borland DLL builds we need other compiler flags so other rules    #
# will be defined for builds of a GAMMA (& PyGAMMA) DLL.		#
#                                                                       #
#########################################################################

{${SRCDIR}\${BASICS}\}.cc{${BINDIR}\}.obj:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${MATRIX}\}.cc{${BINDIR}\}.obj:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${HSPACE}\}.cc{${BINDIR}\}.obj:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${LEVEL1}\}.cc{${BINDIR}\}.obj:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${LSPACE}\}.cc{${BINDIR}\}.obj:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${LEVEL2}\}.cc{${BINDIR}\}.obj:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${BLOCH}\}.cc{${BINDIR}\}.obj:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${GAMIO}\}.cc{${BINDIR}\}.obj:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${BWR}\}.cc{${BINDIR}\}.obj:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${PULSES}\}.cc{${BINDIR}\}.obj:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${INTRANK2}\}.cc{${BINDIR}\}.obj:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${FLOQUET}\}.cc{${BINDIR}\}.obj:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${GRADIENTS}\}.cc{${BINDIR}\}.obj:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${MULTISYS}\}.cc{${BINDIR}\}.obj:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${ESRLIB}\}.cc{${BINDIR}\}.obj:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${DEPREC}\}.cc{${BINDIR}\}.obj:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${TESTING}\}.cc{${BINDIR}\}.obj:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

#########################################################################
#                                                                       #
#                    Build GAMMA DLL Pattern Rules			#
#                                                                       #
# These rules specify how we build object file (*.obj) from C++ code    #
# files (*.cc). Borland make has a built in implicit pattern rule to do #
# a similar task:                                                       #
#                                                                       #
# .cpp.obj:                                                             #
#    bcc32 -c -ncobj $<                                                 #
#                                                                       #
# But that does not suffice for good reasons. First, GAMMA source files #
# reside in module directories off of the source directory SRCDIR.      #
# Second, we want all the object files to be built in the binaries      #
# directory, BINDIR. Thus we must build ${BINDIR}\*.obj from code files #
# ${SRCDIR}\${MODDIR}\*.cc. The main GAMMA makefile handles this by	#
# recursing through each module directory and letting it decide how to  #
# build itself. Here we will define a rule for each module directory.   #
# Another reason is that since we use .cc rather than .cpp (preferred   #
# by Borland) for our C++ source file suffix, we need -P set as a flag  #
# on the compiler line to force a C++ compilation on a .cc file.        #
# Lastly, since the object files for the GAMMA DLL will be different	#
# than those for the static library, instead of the suffix .obj we will #
# use .o to clearly distinguish them from those for the static lib.     # 
#                                                                       #
# Compiler Flags							#
# ==============							#
#    -c 	Compile only, don't call linker (i.e. leave as object)	#
#   -WM-        Do not multi-thread 					#
#   -WR 	Dynamic linked 						#
#   -WD 	Build for a DLL 					#
#    -v		Include debug info					#
#                                                                       #
# zum beispiel:    bcc32 -c -WM- -WR -WD -v file1 file2 		#
#                                                                       #
#########################################################################

{${SRCDIR}\${BASICS}\}.cc{${BINDIR}\}.o:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${MATRIX}\}.cc{${BINDIR}\}.o:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${HSPACE}\}.cc{${BINDIR}\}.o:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${LEVEL1}\}.cc{${BINDIR}\}.o:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${LSPACE}\}.cc{${BINDIR}\}.o:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${LEVEL2}\}.cc{${BINDIR}\}.o:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${BLOCH}\}.cc{${BINDIR}\}.o:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${GAMIO}\}.cc{${BINDIR}\}.o:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${BWR}\}.cc{${BINDIR}\}.o:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${PULSES}\}.cc{${BINDIR}\}.o:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${INTRANK2}\}.cc{${BINDIR}\}.o:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${FLOQUET}\}.cc{${BINDIR}\}.o:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${GRADIENTS}\}.cc{${BINDIR}\}.o:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${MULTISYS}\}.cc{${BINDIR}\}.o:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${ESRLIB}\}.cc{${BINDIR}\}.o:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${DEPREC}\}.cc{${BINDIR}\}.o:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

{${SRCDIR}\${TESTING}\}.cc{${BINDIR}\}.o:
	$(CXX) ${CPPFLAGS} -I$(INCLUDES) -o$@ $<

#########################################################################
#                                                                       #
#                    Library Build Pattern Rules			#
#                                                                       #
# When building a static library the program tlib.exe is used by 	#
# Borland to link together object files. Unfortunately, the syntax for	#
# tlib demands that one add in individual files with a "+" command, 	#
# e.g. tlib libfoo.a +foo.obj. This is a real pain when multiple files  #
# are to be added automatically. Alternatively, tlib does allow for     #
# the switch /a to add other files. In order to automatic this process  #
# a "fake" pattern rule to build foo.a (not libfoo.a) is set so that we #
# can automatically  use tlib to add foo.o to libfoo.a whenever we 	#
# make foo.a. That is if a make is done on say Gconstants.a then the	#
# rule will add Gconstants.o to the library libgamma.a. The rule uses	#
# command line quotes so that the tlib program will not be confused.	#
# There may be a very simple way to accomplish this same thing with	#
# tlib but I sure as hell cannot find it in any documentation!		#
#                                                                       #
#########################################################################

{${BINDIR}\}.obj{${BINDIR}\}.a:
	@echo Adding $< To Static Library ${LIB_NAME}
	${AR} "${BINDIR}\$(LIB_NAME)" /a "$<"

#{${BINDIR}\}.obj{${BINDIR}\}.a:
#	@echo Adding $< To Static Library ${LIB_NAME}
#	${AR} "${BINDIR}\$(LIB_NAME)" /a "$<"


#########################################################################
#                                                                       #
#                              Main Targets                             #
#                                                                       #
# These targets produce the GAMMA and PyGAMMA libraries.                #
#                                                                       #
# Supplied Targets:                                                     #
# =================                                                     #
#                                                                       #
# all: - Builds all three libraries, libgamma.a, gamma.dll, pygamma.dll #
# lib: - Builds only the GAMMA static library, libgamma.a               #
# dll: - Builds only the GAMMA dynamic library, gamma.dll               #
# pyg: - Builds only the PyGAMMA dynamic library, pygamma.dll           #
#                                                                       #
# Variables Needed:                                                     #
# =================                                                     #
# BINDIR   = Borland binaries directory (..\..\i686-pc-borland)         #
# LIB_NAME = GAMMA static library name (libgamma.a)                     #
# DLL_NAME = GAMMA dynamic library name (gamma.dll)                     #
# PYG_NAME = PyGAMMA dynamic library name (pygamma.dll)                 #
# DLL_NAME = GAMMA dynamic library name (gamma.dll)                     #
#                                                                       #
#########################################################################

all: $(BINDIR)\$(LIB_NAME)
#all: $(BINDIR)\$(LIB_NAME) $(BINDIR)\$(DLL_NAME) $(BINDIR)\$(PYG_NAME)

lib: $(BINDIR)\$(LIB_NAME)
dll: $(BINDIR)\$(DLL_NAME)
#pyg: $(BINDIR)\$(PYG_NAME)

${LIB_NAME}: ${BINDIR}\${LIB_NAME}
${DLL_NAME}: ${BINDIR}\${DLL_NAME}
${PYG_NAME}: ${BINDIR}\${PYG_NAME}

#########################################################################
#                                                                       #
#                      Build The GAMMA Static Library                   #
#                                                                       #
# LIB_SRCS    = All code files to be put into the library.              #
# LIB_OBJS    = All object files to be put into the library.            #
# LIB_NAME    = Name of library to be generated/targeted.  (libgamma.a) #
# LIB_OBJS    = Name of object files used in library.                   #
#                                                                       #
# The static library build depends on the object files in LIB_OBJS. If  #
# or when these are up to date then the target uses ar to form the      #
# library from the object files and then ranlib to adjust the library.  #
#                                                                       #
# The LIB_OBJS variable is set from LIB_SRCS earlier in this file.      #
# These are apparently implicitly dependent upon the source codes in    #
# LIB_SRCS (i.e. the .cc file with the same base name as the .obj file) #
# & have an implicit pattern rule as to how the .cc files are compiled  #
# into .o files. This pattern rule, as specified in the documentation   #
# for GNU make, is                                                      #
#                                                                       #
# %.o : %.cc                                                            #
#        $(CXX) -c $(CPPFLAGS) $(CXXFLAGS) $< -o $@                     #
#                                                                       #
# This implicit rule can be replaced by defining a new pattern rule     #
# with the same target and prerequisites, but different commands.       #
# If there are no commands following the rule, the rule is cancelled.   #
# When the new rule is defined, the built-in one is replaced. The new   #
# rule's position in the sequence of implicit rules is determined by    #
# where you write the new rule and affects how they are chained.        #
#                                                                       #
# /P64 Sets the pagesize of the library. Set larger as the library gets #
#      bigger (16, 32, 64, 128,....)					#
#                                                                       #
#########################################################################

AR      = tlib
ARFLAGS = /P64 
    
#${BINDIR}\$(LIB_NAME): ${LIB_OBJS}
${BINDIR}\$(LIB_NAME): ${BINDIR} ${LIB_OBJS}
	@echo *
	@echo * Building Static Library $(LIB_NAME) From Object Files
	@echo *
	@echo * . Removing Any Existing Static Library
	@echo * . Deleted Library: ${BINDIR}\${LIB_NAME}
	@if exist ${BINDIR}\${LIB_NAME} del ${BINDIR}\${LIB_NAME}
	@echo *
	@echo * . Adding Object Files To Fresh Static Library
	@echo *
        @${AR} ${ARFLAGS} "${BINDIR}\$(LIB_NAME)" +"${BINDIR}\Gconstants.obj"
	@make ${LIB_A}
#	TLIB "$@" @&&| 
#        +-$(**: = &^
#        +-)
#|

# Something like this (below) is supposed to work work putting the object files
# into the library (if the dependency on BINDIR is removed in the target...)
# This will expand $@ into ${BINDIR}\${LIB_NAME} and @&& expands into a temporary
# response file. The | are used to place bounds on what goes into the response
# files. The +- is used to indicate add or refresh the files in the library
# for the tlib program. Then **: = &^ does a string substitution on LIB_OBJS
# to add a linefeed to the end of each of its values (object file names). 
# This substitutes all space characters in dependency list (LIB_OBJS) with a 
# space followed by an ampersand (&) followed by the new-line character followed 
# by "+-". This make each line appear as +-foo1.obj &. It will leave a final line
# that contains only +- with no file name. It screws up because of the filename
# contents which could be fixed using quotes but when quotes are used then tlib
# has even more problems or the expansion does. Bottom line, does not work unless
# a way to set the object file path is found.

# I do not know why it is failing.
#
#        TLIB $@ @&&|
#        +-$(**: = &^
#        +-)
#|

#########################################################################
#                                                                       #
#                Build The GAMMA DLL And The Exports Library            #
#                                                                       #
# DLL_NAME    = Name of DLL to be generated/targeted.      (gamma.dll)  #
# DLL_EXP_LIB = Name of exports library generated.    (libgamma.dll.a)  #
# DLL_OBJS    = Name of object files used in DLL.                       #
# DLL_LDFLAGS = Flags used in DLL build.     (-Wl,--export-all-symbols) #
# DLL_LDLIBS  = Libraries DLL depends upon.                             #
#                                                                       #
# The DLL build depends on the object files in DLL_OBJS. If or when     #
# these are up to date then the target uses g++ to form the DLL from    #
# the object files using appropriate linking commands.                  #
#                                                                       #
# The DLL_OBJS variable is set from DLL_SRCS earlier in this file.      #
# These are one and the same as LIB_OBJS for the build so the two are   #
# identical. As with LIB_OBJS, the objects files are implicitly         #
# dependent upon the source codes in DLL_SRCS (i.e. the .cc file with   #
# the same base name as the .o file) & have an implicit pattern rule as #
# to how the .cc files are compiled into .o files. This pattern rule,   #
# as specified in the documentation for GNU make, is                    #
#                                                                       #
# %.o : %.cc                                                            #
#        $(CXX) -c $(CPPFLAGS) $(CXXFLAGS) $< -o $@                     #
#                                                                       #
# ilink32 /Tpd/aa/Gn/c/v c0d32 file1 file2,file1,,import32 cw32i,file1.def 
# /Tpd create a DLL 
# /aa Windows GUI program 
# /Gn don't use state files 
# /c case sensitive link 
# /v Include debug info 
# c0d32.obj startup code for a DLL 
# import32.lib import library for Windows functions 
# cw32i.lib compiler's dynamic linked runtime library 
# Don't overlook the doubled comma on the command line 
#                                                                       #
#########################################################################

#sosi

$(BINDIR)\$(DLL_EXP_LIB): $(BINDIR)\$(DLL_NAME)


$(BINDIR)/$(DLL_NAME) $(BINDIR)/$(DLL_EXP_LIB): $(DLL_OBJS)
        @echo
        @echo "Making DLL $(DLL_NAME) & Imports Library $(DLL_EXP_LIB) From Object Fil
        @echo
#        $(ILINK32) @&&|
#        $(L_FLAGS) $(libDirs) +
#        $(STARTUP) +
#        $(oDir)\Gconstants.obj +
#        $(oDir)\Gutils.obj +
#        ,$<,, +
#        $(WINIMPORTLIB).lib +
#        $(RTLIB) +
#|

#        ${CXX} -shared -Wl,--out-implib=${BINDIR}/$(DLL_EXP_LIB) \
#        -o ${BINDIR}/$(DLL_NAME) $(DLL_OBJS) $(DLL_LDFLAGS) $(DLL_LDLIBS)

#########################################################################
#                                                                       #
#                   Insure Borland Binaries Directory Exists            #
#                                                                       #
#########################################################################

${BINDIR}:
	@if not exist .\${BINDIR} mkdir ${BINDIR}

#          echo "First Constructing Borland Binaries Directory For GAMMA"
#          echo "Making Directory .\$(BINDIR)"
#	if not exist .\${BINDIR} mkdir ${BINDIR}

force:

clean:
	-del ${BINDIR}\*.obj
	-del ${BINDIR}\*.BAK
	-del ${BINDIR}\libtmp*.*
#	-del ${BINDIR}\*.il?
#	-del ${BINDIR}\*.csm
#	-del ${BINDIR}\*.tds

distclean:
	-del ${BINDIR}\*.obj
	-del ${BINDIR}\*.BAK
	-del ${BINDIR}\libtmp*.*
	-del ${BINDIR}\*.lib





#################################################################################
#										#
#                              GAMMA Distributions				#
#										#
# What follows has nothing to do with any builds of GAMMA. This stuff hass been #
# included in this Makefile only so that GAMMA distributions will inlcude the   #
# distributed files in this directory. Do not worry about this for any builds   #
# and or runs of GAMMA programs.						#
#										#
#################################################################################

THISDIR       = Borladn
PRIMALPLAT    = "using Borland C++ compiler"
PRIMALMAKEDIR = ../make
MAINMAKEDIR   = ../../make
SUBDIRS       =
HDRFILES      =
CCFILES       =
HTMLFILES     = index.html
IMGFILES      =
INCFILES      = Makefile MakeMods gamma.in cleanup.bat
DOSCLEANFILES = Makefile gamma.in
UPDATEFILES   = ${HTMLFILES}
DISTSUBDIRS   =
MODLABEL      = ${THISDIR}

include ${PRIMALMAKEDIR}/MakeDists
include ${PRIMALMAKEDIR}/CleanDir
include ${PRIMALMAKEDIR}/MakeHelp
include ${MAINMAKEDIR}/MakeGam
include ${MAINMAKEDIR}/Distribute
include ${MAINMAKEDIR}/Update
include ${MAINMAKEDIR}/DieDOSDie
include ${MAINMAKEDIR}/CopyDelDir
include ${MAINMAKEDIR}/TarZipDir

force:
