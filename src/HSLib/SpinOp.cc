/* SpinOp.cc ****************************************************-*-c++-*-
**                                                                      **
**                               G A M M A                              **
**                                                                      **
**	Spin Operators                            Implementation	**
**                                                                      **
**      Copyright (c) 1991                                              **
**      Z.L. Madi, S. Smith, T. Levante                                 **
**      Eidgenoessische Technische Hochschule                           **
**      Labor fur physikalische Chemie                                  **
**      8092 Zurich / Switzerland                                       **
**                                                                      **
**      $Header: $
**                                                                      **
*************************************************************************/

/*************************************************************************
**                                                                      **
**  Description                                                         **
**                                                                      **
**  Class spin_op embodies quantum mechanical spin operators in either  **
**  a single spin or composite spin Hilbert space.  The selectivity is  **
**  defined by a list of spins specified by a spin system (in class     **
**  spin_sys).                                                          **
**                                                                      **
**  The composite space matrix representation is in the natural basis   **
**  constructed from the direct products of single spin bases.          **
**                                                                      **
**  Spin operators may internally exists as a list of single spin       **
**  arrays whose tensor products form the spin operator, or as a single **
**  composite space array, or both.                                     **
**                                                                      **
*************************************************************************/
 
#ifndef   SpinOp_cc_				// Is file already included?
#  define SpinOp_cc_ 1				// If no, then remember it
#  if defined(GAMPRAGMA)			// Using the GNU compiler?
#    pragma implementation			// this is the implementation
#  endif

#include <HSLib/SpinOp.h>			// Include class header
#include <Basics/Gconstants.h>			// Include PI definition
#include <Basics/Gutils.h>			// Include GAMMA errors
#include <Basics/StringCut.h>			// Include CenterString function
#include <Matrix/matrix.h>			// Include matrices
#include <Matrix/complex.h>			// Inlcude GAMMA complex numbers
#include <HSLib/SpinSys.h>			// Include base spin systems

using std::string;				// Using libstdc++ strings

/* The matrix generated by the spin operator static function FSmx is used to
   define a NULL SOp.  A NULL SOp consistes of a NULL pointer to the sub-space
   arrays (pr==NULL) and a 1x1 identity matrix for the spin operator. Note 
   that, since the spin operator Hilbert space is 2I+1, a Hilbert space of 1 
   would correspond to no spin (I=0). Indeed, a Hilbert space of 1 is used
   to indicate that No Full Space Representation of SOp Exists.              */

matrix spin_op::FSmx=matrix(1,1,i_matrix_type);	// Default FS matrix

// ----------------------------------------------------------------------------
// --------------------------- PRIVATE FUNCTIONS ------------------------------
// ----------------------------------------------------------------------------

// ____________________________________________________________________________
// i                  CLASS SPIN OPERATOR ERROR HANDLING
// ____________________________________________________________________________


	// Input		SOp	: Spin operator (this)
        //                      eidx    : Error index
        //                      noret   : Flag for return (0=linefeed)
        // Output               none    : Error message
        //                                Program execution stopped (fatal)

void spin_op::SOperror(int eidx, int noret) const
  {
  std::string hdr("Spin Operator");
  switch(eidx)
    {
    case 0: GAMMAerror(hdr, 0, noret); break;   // Program Aborting        (0)
    case 9: GAMMAerror(hdr, "Accessed Spin Out of Range", noret);
      break; 					 //                        (9)
    case 10: GAMMAerror(hdr, "Mixing Operators From Different Systems", noret);
      break; 					 //                        (10)
    case 11: GAMMAerror(hdr, "Problems During Operator Addition", noret);
      break; 					 //                        (11)
    case 12: GAMMAerror(hdr, "Problems During Operator Subtraction", noret);
      break; 					 //                        (12)
    case 13: GAMMAerror(hdr, "Problems During Operator Multiplication", noret);
      break; 					 //                        (13)
    case 15: GAMMAerror(hdr, "Bad Full Space Array Reference Counting!", noret);
      break; 					 //                        (15)
    default: GAMMAerror(hdr, eidx, noret); break;// Usually Unknown Error  (-1)
    }
  }


volatile void spin_op::SOpfatality(int eidx) const
  {
  SOperror(eidx, 1);
  if(eidx) SOperror(0);
  GAMMAfatal();					// Clean exit from program
  }

// ____________________________________________________________________________
// ii                CLASS SPIN PRIVATE AUXILIARY FUNCTIONS
// ____________________________________________________________________________

	// Input		SOp	: Spin operator (this)
	// Return		void    : The full Hilbert space matrix
	//			          representaion of SOp is produced
	//				  if it does not already exist.
	// Note				: A 1x1 I matrix is the default "mx" &
	//				  flags that the true mx isn't present
	// Note				: Nothing is done if full mx exists
	// Note				: If the spin operator is truely NULL
	//				  we do nothing anyway since the stored
	//				  full space mx is for I=0 & a bit odd
	// sosi				: Hopefully the tensor_product function
	//				  takes into account matrix structure?
	//				  But this forces the issue anyway!


void spin_op::blow_up() const
  {
  if(mx.rows() == 1)			// "Blow Up" only if not already done
    {					//  as indicated by a 1x1 I matrix
    if(pr == NULL)			//   1.)If no single spin arrays
      {					//	then full array is a zero matrix
      int hs = HS();
      mx = matrix(hs,hs,complex0,d_matrix_type);
      }
    else if(nspins == 1)		//   2.)If 1 spin, full array is just 
      mx = pr[0];			//      first sub-space array
    else				//   3.)If single spin arrays, perform 
      {					//	a tensor product to generate
      for(int i=0; i<nspins; i++) 	// 	full space array representation
	mx = tensor_product(mx,pr[i]);	//	Initial mx is 1x1 I matrix
      }
    }
  }

void spin_op::blow_up(matrix_type t) const
	// Input		SOp	: Spin operator (this)
	// Return		void    : The full Hilbert space matrix
	//			          representaion of SOp is produced
	//				  if it does not already exist.
	// Note				: A 1x1 I matrix is the default "mx" &
	//				  flags that the true mx isn't present
	// Note				: Nothing is done if full mx exists
	// sosi				: Hopefully the tensor_product function
	//				  takes into account matrix structure?
	//				  but this forces the issue!
  {
  blow_up();
  mx.set_type(t);
  }

// ____________________________________________________________________________
// iii             CLASS SPIN OPERATOR CHECKING FUNCTIONS
// ____________________________________________________________________________

int spin_op::checkSpin(int spin, int warn) const

	// Input		SOp	: Spin operator (this)
	//			spin    : A spin index
	//			warn    : Warning level
	//					0 = no warning
	//					1 = non-fatal  warning
	//				       >1 = fatal warning
	// Output		TF	: True if the SOp spin exists

  {
  if(spin>=0 && spin<nspins) return 1;
  if(warn)
    {
    if(warn == 1) SOperror(9, 1);
    else          SOpfatality(9);
    }
  return 0; 
  }


int spin_op::checkSys(const spin_op& SOp1, int warn) const

	// Input		SOp	: Spin operator (this)
	//			SOp1	: Another spin operator
	//			warn    : Warning level
	//					0 = no warning
	//					1 = non-fatal  warning
	//				       >1 = fatal warning
	// Output		TF	: True if the systems associate with 
	//				  the two operators match

  {
  if(nspins == SOp1.nspins)
    {
    int TF = 1;
    for(int i=0; i<nspins && TF; i++)
      TF *= (Hspaces[i] == SOp1.Hspaces[i]);
    if(TF) return 1;
    }
  else if(warn)
    {
    if(warn == 1) SOperror(10, 1);
    else          SOpfatality(10);
    }
  return 0; 
  }


// ____________________________________________________________________________
// iv             CLASS SPIN OPERATOR SETUP FUNCTIONS
// ____________________________________________________________________________

/* This set of functions deals with specification of sub-space Hilbert space.
   Each composite spin operator is associated with a set of spins and each
   spin resides in a spin Hilbert space.  These spin Hilbert spaces are kept
   in each SOp in the array Hspaces.  Unless there is NO operator, these
   dimensions will be maintained, regardless if SOp sub-space arrays exist.
   The total (full space) SOp dimension is the produce of these sub-spaces.
   The sub-space dimensions are set during construction from:

		1. From an input array of (sub-space) matrices
		2. From another input spin operator                          */


void spin_op::CopySubSpaces(matrix* prmxs)
  {
  if(Hspaces) delete [] Hspaces;
  if(!nspins) Hspaces = NULL;
  else        Hspaces = new int[nspins];
  for(int i=0; i<nspins; i++) Hspaces[i] = (prmxs[i]).rows(); 
  }

void spin_op::CopySubSpaces(const spin_op& SOp)
  {
  if(Hspaces) delete [] Hspaces;
  if(!SOp.Hspaces) { Hspaces=NULL; return; } 
  if(!SOp.nspins)    Hspaces = NULL;
  else               Hspaces = new int[nspins];
  for(int i=0; i<nspins; i++) Hspaces[i] = SOp.Hspaces[i];
  }

/* This set of functions deals with specification of spin flags. Each
   composite spin operator is associated with a set of spins.  However each
   SOp need not act on any particular spin.  These flags indicate whether
   SOp is active on the spin or not.  If it is NOT active, the flag will be
   zero and the associated sub-space array (if present) will be an I matrix.
   If SOp is active on a spin, the spin flag will be non-zero and the sub-
   space array (if it exists) will be something else but an I matrix.  The
   spin flags are set during construction from:

		1. From an input array of (sub-space) matrices
		2. From another input spin operator                          */

void spin_op::CopySpinFlags(matrix* prmxs)
  {
  if(spinflags) delete [] spinflags;
  if(!nspins) spinflags = NULL;
  else        spinflags = new int[nspins];
  for(int i=0; i<nspins; i++)
    if(prmxs[i].stored_type() == i_matrix_type) spinflags[i] = 0;
    else                                        spinflags[i] = 1;
  }

void spin_op::CopySpinFlags(const spin_op& SOp)
  {
  if(spinflags) delete [] spinflags;
  if(!SOp.spinflags) { spinflags=NULL; return; }
  if(!SOp.nspins)      spinflags = NULL;
  else                 spinflags = new int[nspins];
  for(int i=0; i<nspins; i++)
    spinflags[i] = SOp.spinflags[i];
  }

void spin_op::ZeroSpinFlags()
  {
  spinflags = new int[nspins];
  for(int i=0; i<nspins; i++) spinflags[i] = 0; 
  }

void spin_op::BlendSpinFlags(const spin_op& SOp)
  { for(int i=0; i<nspins; i++) spinflags[i]+=SOp.spinflags[i]; }


/* This set of functions deals with individual spin SOp matrices. Each
   composite spin operator is associated with a set of spins.  In some
   cases the SOp can be stored as a set of small single spin arrays rather
   than one big (full space) array.  Whereas the full space array will 
   have the dimension of the composite Hilbert space, the sub-space arrays
   reside in the much smaller individual spin Hilbert spaces.  The product
   of the sub-space dimensions equals the full space dimension.  Also the
   tensor product of the sub-space arrays is the full space array. Note
   that not all SOp's can be stored as sub-space arrays in which case they
   will not be present. The subspace arrays are set during construction from:

		1. From an input array of (sub-space) matrices
		2. From another input spin operator                          */

void spin_op::CopySubArrays(matrix* prmxs)
  {
  if(pr) delete [] pr;
  if(!nspins) pr = NULL;
  else        pr = new matrix[nspins];
  for(int i=0; i<nspins; i++)
    pr[i] = prmxs[i];
  }

void spin_op::CopySubArrays(const spin_op& SOp)
  {
  if(pr) delete [] pr;
  if(!SOp.pr)     { pr = NULL; return; }
  if(!SOp.nspins)   pr = NULL;
  else              pr = new matrix[nspins];
  for(int i=0; i<SOp.nspins; i++)
    pr[i] = SOp.pr[i];
  }

void spin_op::DelSubArrays()
 { if(pr != NULL) { delete [] pr; pr = NULL; } }


// ----------------------------------------------------------------------------
// ---------------------------- PUBLIC FUNCTIONS ------------------------------
// ----------------------------------------------------------------------------

// ____________________________________________________________________________
// A                CLASS SPIN OPERATOR CONSTRUCTORS, DESTRUCTOR
// ____________________________________________________________________________


spin_op::spin_op()
  {
  nspins    = 0;				// No spins
  Hspaces   = NULL;				// No subspaces
  spinflags = NULL;				// No spin flags
  pr        = NULL;				// No subspace arrays
  mx        = spin_op::FSmx;			// Set default full space mx  
  }
  
spin_op::spin_op(int spins, matrix* prmxs)
  {
  nspins    = spins;				// Copy the # of spins;
  Hspaces   = NULL;				// So far no subspaces
  spinflags = NULL;				// No spin flags set
  pr        = NULL;				// No subspace arrays
  CopySubArrays(prmxs);				// Copy subspace arrays
  CopySubSpaces(prmxs);				// Copy spaces from
  CopySpinFlags(prmxs);				// Set the spin flags
  mx = spin_op::FSmx;				// Set default full space mx  
  }

spin_op::spin_op(const spin_op &SOp)
  {
  nspins    = SOp.nspins;			// Copy the # of spins
  pr        = NULL;				// No subspace arrays
  Hspaces   = NULL;				// No subspace dimensions
  spinflags = NULL;				// No spin flags
  if(SOp.pr!=NULL)         CopySubArrays(SOp);	// Copy subspace arrays(if any)
  if(SOp.Hspaces!=NULL)    CopySubSpaces(SOp);	// Copy subspace sizes (if any)
  if(SOp.spinflags!= NULL) CopySpinFlags(SOp);	// Copy spin flags if existing
  mx = SOp.mx;					// Copy full array
  }

spin_op::~spin_op()
  {
  if(Hspaces)   delete [] Hspaces;	// Delete the spin Hilbert spaces
  if(spinflags) delete [] spinflags;	// Delete the spin flags
  if(pr)        delete [] pr;		// Delete the single spin arrays
  }					// Note that mx will self-destruct


spin_op& spin_op::operator= (const spin_op &SOp)
  {
  if(this == &SOp) return *this;		// Do nothing if already equal 
  nspins = SOp.nspins;				// Copy the number of spins 
  CopySubArrays(SOp);				// Copy subspace arrays(if any)
  CopySubSpaces(SOp);				// Copy subspace sizes (if any)
  CopySpinFlags(SOp);				// Copy spin flags if existing
  mx = SOp.mx;					// Copy full array from SOp
  return *this;
  }

// ____________________________________________________________________________
// B                 SPIN OPERATOR - SPIN OPERATOR FUNCTIONS
// ____________________________________________________________________________
 
 
/* These functions allow for simple mathematical operations between two spin
   operators.  This includes addition, subtraction, multiplication. There is
   one unary function as well, negation.
 
   Operator Arguments      Result        Operator Arguments    Result
   -------- --------- -----------------  -------- --------- -------------------   
      -        SOp    Returns -SOp          -=    SOp,SOp1  SOp1 subt. from SOp
      +     SOp,SOp1  Returns SOp+SOp1       *    SOp1,SOp2 Returns SOp1*SOp2 
     +=     SOp,SOp1  SOp1 added to SOp     *=    SOp,SOp1  SOp mult into SOp1
      -     SOp1,SOp2 Returns SOp1-SOp2                                      */

spin_op spin_op::operator- () const
  {
  spin_op SOp(*this);				// Begin with copy of input SOp
  if(mx.rows() > 1) SOp.mx = mx.operator- (); 	// Negate full mx (if exists)
  if(pr!=NULL) SOp.pr[0]= (pr[0]).operator- ();	// Negate 1st single spin array 
  return SOp;					// if subspace arrays exist
  }

spin_op spin_op::operator+ (const spin_op &SOp1) const
  { spin_op SOp(*this); SOp+=SOp1; return SOp;}

spin_op & spin_op::operator+= (const spin_op &SOp1)
{
  if(pr==NULL && mx.rows()==1)		// If this is an empty spin operator
  { 
    *(this)=SOp1; // then just assign it from SOp1
    return *this; 
  } 		

  if(!checkSys(SOp1))  // Insure spin systems match up
     SOpfatality(11); 	

  blow_up();				// Must use full space array for +
  SOp1.blow_up();			// Must use full space array for +
  mx += SOp1.mx;			// Add the two full space arrays
  DelSubArrays(); 			// Delete sub-space arrays (invalid)
  BlendSpinFlags(SOp1);			// Adjust SOp spin flags
  return *this;
}

spin_op operator- (const spin_op &SOp1, const spin_op &SOp2)
  { spin_op SOp(SOp1); SOp-=SOp2; return SOp;}

	// Input		SOp    : Spin operator (this)
	// Return		SOp1   : Spin operator to be subtracted from SOp
	// 				        SOp = SOp - SOp1

spin_op & spin_op::operator-= (const spin_op &SOp1)
{
  if(pr==NULL && mx.rows()==1)		// If this is an empty spin operator
  { 
    *(this) = -SOp1; // then just assign it from -SOp1
    return *this; 
  } 	
 
  if(!checkSys(SOp1)) SOpfatality(12); 	// Insure spin systems match up
  blow_up();				// Must use full space array for -
  SOp1.blow_up();			// Must use full space array for -
  mx -= SOp1.mx;			// Subtract off SOp1 full space array
  DelSubArrays();			// Delete sub-space arrays (invalid)
  BlendSpinFlags(SOp1);			// Adjust SOp spin flags
  return *this;
}

spin_op operator* (const spin_op &SOp1, const spin_op &SOp2)
  { spin_op SOp(SOp1); SOp*=SOp2; return SOp;}

spin_op & spin_op::operator*= (const spin_op &SOp1)
{
  if(pr==NULL && mx.rows()==1)		// If this is an empty SOp 
    return *this; 				    // we can just return empty
  if(!checkSys(SOp1)) SOpfatality(13); 	// Insure spin systems match up
  if((pr!=NULL)&&(SOp1.pr!=NULL))	// If single spin arrays exist
    {					// then perform multiplication
    for(int i=0; i<nspins; i++) 	// in single spin subspaces
      pr[i] *= SOp1.pr[i];
    if(mx.rows() > 1)			// If there is a full space
      mx = spin_op::FSmx;		// set to default full space mx  
    }
  else					// If single spin subspaces
    {					// don't exist we have to do
    blow_up();				// multiplcaton in the full
    SOp1.blow_up();			// spin Hilbert space
    mx *= SOp1.mx;			// Multiply full space arrays
    }
  BlendSpinFlags(SOp1);			// Adjust SOp spin flags

  return *this;
}


// ____________________________________________________________________________
// C                      SPIN OPERATOR - SCALAR FUNCTIONS
// ____________________________________________________________________________

/* These functions allow for two mathematical operations between a scalar &
   a spin operators, multiplication & division.

 Operator Arguments      Result        Operator Arguments    Result
 -------- --------- -----------------  -------- --------- -------------------
    *      z,SOp    Returns z*SOp          *=    SOp,z    SOp multiplied by z
    *      SOp,z    Returns z*SOp          *=    SOp,d    SOp multiplied by d
    *      d,SOp    Returns d*SOp          /     SOp,z    Returns (1/z)*SOp
    *      SOp,d    Returns SOp*d          /     SOp,d    Returns (1/d)*SOp
    /=     SOp,d    SOp mult. by (1/d)     /=    SOp,z    SOp mult. by (1/z) */


spin_op operator* (const spin_op& SOp1, const complex& z)
  { spin_op SOp(SOp1); SOp *= z; return SOp;}

spin_op operator* (const spin_op& SOp1, double r)
  { spin_op SOp(SOp1); SOp *= r; return SOp;}

spin_op operator* (const complex& z, const spin_op& SOp1)
  { spin_op SOp(SOp1); SOp *= z; return SOp;}

spin_op operator* (double r, const spin_op& SOp1)
  { spin_op SOp(SOp1); SOp *= r; return SOp;}

spin_op & spin_op::operator*= (const complex& z)
{
  if(mx.rows()>1) mx    *= z;		// Multiply in full space
  if(pr!= NULL)   pr[0] *= z;		// Multiply in sub-space
  return *this;
}

spin_op & spin_op::operator*= (double r) 
{ 
  (*this) *= complex(r,0); 
  return *this;
}

spin_op       operator/  (const spin_op &SOp1, const complex& z) {return SOp1*(1/z);}
spin_op       operator/  (const spin_op &SOp1, double r)         {return SOp1*(1/r);}

spin_op & spin_op::operator/= (const complex& z)
{ 
  (*this) *= (1/z); 
  return *this;
}

spin_op & spin_op::operator/= (double r)
{ 
  (*this) *= (1/r); 
  return *this;
}

// ____________________________________________________________________________
// D                    SPIN OPERATOR - MATRIX FUNCTIONS
// ____________________________________________________________________________

spin_op::operator matrix() const { blow_up(); return mx; }
matrix spin_op::get_mx()   const { blow_up(); return mx; }

// ____________________________________________________________________________
// E                  SPIN OPERATOR ASSOCIATED FUNCTIONS
// ____________________________________________________________________________

spin_op spin_op::adjoint() const
  {
  spin_op SOp(*this);
  SOp.blow_up();			// Blowing up submatrices!!!
  SOp.mx = (SOp.mx).adjoint();		// Taking adjoint of full array
  SOp.DelSubArrays();			// Delete any sub-space arrays
  return SOp;				// Return with only full matrix
  }

complex spin_op::trace() const
  {
  complex z(0);			// Begin with nothing
  if(mx.rows()>1) 		// Trace is easiest on the full
    z = mx.trace(); 		// space array if it exists 
  else if(pr!=NULL)		// No big mx, so we take the trace from
    { 				// single spin space arrays without blowing
    z = 1; 			// up SOp
    for(int i=0; i<nspins; i++)
      z *= (pr[i]).trace();
    }
  return z;
  }

spin_op spin_op::exp() const
  {
  spin_op SOp(*this);			// Make a copy of input SOp
  matrix mxd, mxev;			// Used in matrix diagonalizaion
  SOp.blow_up();			// Generate full space array
  diag(SOp.mx, mxd, mxev);		// Diagonalize it (into mxd & mxev)
  matrix mxdexp = mx.exp();		// Take diagonal exponential
  SOp.mx = mxev*mxdexp*mxev.adjoint();	// Reform in original basis 
  SOp.DelSubArrays();			// Delete any sub-space arrays
  return SOp;				// Were all done
  }

spin_op adjoint(const spin_op& SOp) { return SOp.adjoint(); }
complex trace(const spin_op& SOp)   { return SOp.trace(); }
spin_op exp(const spin_op& SOp)     { return SOp.exp(); }

int spin_op::spins( )    const { return nspins; }
int spin_op::refs( )     const { return mx.refs(); }
int spin_op::refs(int i) const { checkSpin(i); return (pr[i]).refs(); }

int spin_op::HS( ) const

	// Input		SOp	: Spin operator (this)
	// Output		hs	: Full spin Hilbert space

  {
  int hs =    mx.rows();
  if(hs>1)    return hs;
  if(!nspins) return 0;
  hs = 1;
  if(Hspaces)
    for(int i=0; i<nspins; i++) hs *= Hspaces[i];
  return hs;
  }

// ____________________________________________________________________________
// F                       SPIN OPERATOR I/O FUNCTIONS
// ____________________________________________________________________________


	// Input		SOp	: Spin operator (this)
	// 			ostr	: An output stream
	//			full    : Flag for how much output
	//				    0 = Output Full Space Array
	// Return		void	: SOp information put into ostr

void spin_op::print(std::ostream& ostr, int full) const
  {
  if(pr != NULL) blow_up(); 			// Need full space operator
  if(mx.rows()>1) ostr << mx;			// Now, print full space array 
  else ostr << "\n\tNULL Spin Operator";	// If NULL, print thats so
  if(full) ostr << "\n";
  }

std::ostream& operator<< (std::ostream& ostr, const spin_op &SOp)
 { SOp.print(ostr); return ostr; }

void spin_op::status(int full) const
 
	// Input		SOp	: Spin operator (this)
        //                      full	: Flag for amount of output
        // Output               void	: Outputs SOp status

  {
  int k;
  std::cout << "\n\tComposite Space For " << nspins << " Spins";
  if(Hspaces)
    {
    std::cout << "\n\tSubspace Dimensions: ";
    for(k=0; k<nspins; k++) std::cout << Hspaces[k] << " ";
    }
  if(spinflags)
    {
    std::cout << "\n\tSpin Activities: ";
    for(k=0; k<nspins; k++) std::cout << spinflags[k] << " ";
    }
  if(pr != NULL)
    { 
    int ns = nspins;
    std::cout << "\n\t" << nspins;
    if(ns>1) std::cout << " SubSpace Arrays Exist";
    else     std::cout << " SubSpace Array Exists";
    for(int i=0; i<ns; i++)
      {
      std::cout << "\n\tArray " << i << "\n" << pr[i];
      pr[i].status(full);
      }
    }
  else 
    std::cout << "\n\tNo SubSpace Arrays Present";
  if(mx.rows() >1)
    std::cout << "\n\tFull Space Array Exists";
  else
    std::cout << "\n\tDefault 1x1 Full Space Array Only";
  mx.status(full);
  }


// ____________________________________________________________________________
// G                       SPIN OPERATOR KLUDGE
// ____________________________________________________________________________

// This function forces a Spin operator's matrix to take on a specific
// matrix structure.  Its a kludge because so far GAMMA's matrices don't know
// how to keep a proper matrix structure un the "blow up" funciton.  When this
// is fixed, remove this function and all places where its used.

void spin_op::FaxisStruct(char axis) const
  {
  switch(axis)
    { case 'z': case 'e': case 'a': case 'b': blow_up(d_matrix_type); }
  }


// ____________________________________________________________________________
// H                         PyGAMMA Code (Member)
// ____________________________________________________________________________


#ifdef PYGAMMA					// Begin PyGAMMA code block

#include <sstream>				// Know about string streams

// Code for constructor (int, matrix*)
spin_op::spin_op(int spins, matrix prmxs)
  {
  nspins    = spins;				// Copy the # of spins;
  Hspaces   = NULL;				// So far no subspaces
  spinflags = NULL;				// No spin flags set
  pr        = NULL;				// No subspace arrays
  CopySubArrays(&prmxs);			// Copy subspace arrays
  CopySubSpaces(&prmxs);			// Copy spaces from
  CopySpinFlags(&prmxs);			// Set the spin flags
  mx = spin_op::FSmx;				// Set default full space mx  
  }

//-----------------------------------------------------------------------------
//                            ASCII OUTPUT FUNCTIONS
//-----------------------------------------------------------------------------

std::string spin_op::PyPrint()
  {
  std::stringstream sstr;			// Like ostream but with strings
  if(pr != NULL) blow_up(); 			// Need full space operator
  std::string hdr;
  if(mx.rows() <= 1)
    {
    hdr = std::string("Empty Spin Operator");
    sstr << CenterString(hdr) << std::endl;
    return sstr.str();
    }
  hdr = std::string("Spin Operator");
  sstr << CenterString(hdr) << std::endl;
  sstr << mx;
  return sstr.str();
  }
// ____________________________________________________________________________
// K                             Python Code (Non-Member)
// ____________________________________________________________________________

#include <boost/python/class.hpp>			// Boost.Python classes
#include <boost/python/operators.hpp>			// Boost.Python operators
#include <boost/python/overloads.hpp>
#include <boost/python/copy_const_reference.hpp>	// Boost.Python call policy
#include <boost/python/return_value_policy.hpp>		// Boost.Python return policy

using boost::python::init;
using boost::python::self;
using boost::python::return_value_policy;
using boost::python::copy_const_reference;

BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS(spinop_refs, spin_op::refs, 0, 1)

void PySpinOp()
  {
//                                  The Class

  boost::python::class_<spin_op>("spin_op", init<>())

//                                Constructors

    .def(init<int, matrix*>())
    .def(init<const spin_op&>())

//                              Operators

    .def(     -  self)
    .def(self +  self)
    .def(self -  self)
    .def(self *  self)
    .def(self += self)
    .def(self -= self)
    .def(self *= self)

    .def(self      *  complex())
    .def(self      *  double())
    .def(complex() *  self)
    .def(double()  *  self)
    .def(self      *= complex())
    .def(self      *= double())
    .def(self      /  complex())
    .def(self      /  double())
    .def(self      /= complex())
    .def(self      /= double())

    .def("get_mx", &spin_op::get_mx)

// The matrix type-cast matrix() has not been exported

    .def("exp",     &spin_op::exp)
    .def("adjoint", &spin_op::adjoint)
    .def("trace",   &spin_op::trace)

    .def("spins", &spin_op::spins)
    .def("refs",  (int(spin_op::*) (int))0, spinop_refs())
    .def("HS",    &spin_op::HS)

//                      Python Specialty Functions

    .def("__str__", &spin_op::PyPrint)
  ;

//                        Friend Functions

// The friend functions are not exported, only the member versions above.

  }
#endif						// End of PyGAMMA code

#endif 						// SpinOp.cc
