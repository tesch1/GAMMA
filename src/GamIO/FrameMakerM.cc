/* FrameMakerM.cc ***********************************************-*-c++-*-
**									**
**	                        G A M M A 				**
**								 	**
**	FrameMaker MIF Functions                  Implementation   	**
**						 			**
**	Copyright (c) 1991, 1992		 			**
**	Tilo Levante, Scott Smith, Beat Meier				**
**	Eidgenoessische Technische Hochschule			 	**
**	Labor fuer physikalische Chemie				 	**
**	8092 Zurich / Switzerland				 	**
**								 	**
**      $Header: $
**								 	**
*************************************************************************/

/*************************************************************************
**                                                                      **
** Description                                                          **
**                                                                      **
** The FrameMaker Library provides functions to create different        **
** structures readable in the desktop publishing program FrameMaker.    **
** This module is part of the FrameMaker set in GAMMA and contains the  **
** functions that output common MIF constructs.                         **
**                                                                      **
*************************************************************************/


#ifndef   FrameMakerM_cc_			// Is file already included?
#  define FrameMakerM_cc_ 1			// If no, then remember it
#  if defined(GAMPRAGMA)			// Using the GNU compiler?
#    pragma implementation			// This is the implementation
#  endif

#include <GamIO/FrameMakerM.h>			// Include the header
#include <GamIO/FrameMakerP.h>			// Include FM parameters
#include <Basics/Gconstants.h>			// Include PI
#include <Basics/StringCut.h>			// Gdec/Gform (dec/form) functions
#include <iostream>				// Include input output streams
#include <string>				// Include libstdc++ STL strings

using std::string;				// Using libstdc++ strings
using std::ostream;				// Using libstdc++ output streams


// ____________________________________________________________________________
// A                     FRAMEMAKER MIF BASIC CONSTUCTS 
// ____________________________________________________________________________


int FM_ID()

        // Input        none    : none
        // Output       int     : The internal FM object ID
        //                        is incremented and returned

  {
  static int id=0;				// This is object ID #
  id++;						// Just update by 1
  return id;
  }
  
void FM_Begin(ostream &out)
  { out << "<MIFFile 2.00> # Generated by GAMMA 3.6\n"; }
void FM_End(ostream &out)
  { out << "# end of MIFFile\n"; }


void FM_Group(ostream &out, int ID, int GroupID)

	// Input	out       : output stream
	// 		ID        : ID number
	// 		GroupID   : Group ID number
	// Output	none      : Function is void.  Puts the commands
	//			    to group all graphic objects with
	//			    i.d. ID together with i.d. GroupID

   {
   out << "      <Group                                  \n";
   out << Gform( "          <ID %d>\n", ID);
   if(GroupID)
     out << Gform( "          <GroupID %d>\n", GroupID);
   out << "      > # end of Group                        \n";
   return;
   }


// ____________________________________________________________________________
// B                 FRAMEMAKER MIF ANCHORED FRAME CONSTUCTS 
// ____________________________________________________________________________


void FM_AFrames_Begin(ostream &out)
 
        // Input        ostr    : An output stream
        // Output       void    : The output stream is modified
        //                        to contain an anchored frame start

  { out << " <AFrames\n"; }


void FM_AFrames_End(ostream &out)
 
        // Input        ostr    : An output stream
        // Output       void    : The output stream is modified
        //                        to contain an anchored frame end

  { out << " >    # end of AFrames\n"; }


void FM_AFrame_Set(ostream &out, double xsize, double ysize, int ID)
 
        // Input        ostr    : An output stream
	//		xsize	: Frame horizontal dimensions in cm
	//		ysize	: Frame vertical dimensions in cm
	//		ID	: Anchored frame ID
        // Output       void    : The output stream is modified
        //                        to contain anchored frame settings

  {
  out << "  <Frame					\n";
  out << Gform("  <ID %d>\n", ID);
  out << "  <Pen 15>					\n";
  out << "  <Fill 7>					\n";
  out << "  <PenWidth  0.5 pt>				\n";
  out << "  <Separation 0>				\n";
  out << Gform("  <BRect 0.0 cm 0.0 cm %3.3f cm ",xsize);
  out << Gform("%3.3f cm>\n", ysize);
  out << "  <FrameType Below >				\n";
  out << "  <Float Yes>					\n";
  out << "  <NSOffset  0.0 \">				\n";
  out << "  <AnchorAlign Center >			\n";
  out << "  <Cropped No >				\n";
  out << "  <Pen 0>					\n";
  }


void FM_AFrame_Set(ostream &out, const FMPar& FMP, int ID)

        // Input	out	: Open output stream
	//		FMP	: FrameMaker plot parameters
	//		ID	: FrameMaker ID value
	// Output	void	: The output stream is modified to
	//			  contain the start of an anchored
	//			  in FrameMaker MIF format
	// Note			: The anchored frame height & width
	//			  in cm is taken from FMP
	// Note			: The anchored frame will have ID

  {
  double vs = FMP.VPlotSize();
  double hs = FMP.HPlotSize();
  out << "  <Frame					\n";
  out << Gform("  <ID %d>\n", ID);
  out << "  <Pen 15>					\n";
  out << "  <Fill 7>					\n";
  out << "  <PenWidth  0.5 pt>				\n";
  out << "  <Separation 0>				\n";
  out << Gform("  <BRect 0.0 cm 0.0 cm %3.3f cm ", hs);
  out << Gform("%3.3f cm>\n", vs);
  out << "  <FrameType Below >				\n";
  out << "  <Float Yes>					\n";
  out << "  <NSOffset  0.0 \">				\n";
  out << "  <AnchorAlign Center >			\n";
  out << "  <Cropped No >				\n";
  out << "  <Pen 0>					\n";
  }


void FM_AFrame_End(ostream &out)

        // Input        ostr    : An output stream
        // Output       void    : The output stream is modified
        //                        to contain end of anchored frame

   { out << "    > # end of Frame				\n"; }


// ____________________________________________________________________________
// C                    FRAMEMAKER MIF TEXT FLOW CONSTUCTS
// ____________________________________________________________________________
                                                                   

void FM_TextFlow_Set(ostream &out)

        // Input        ostr    : An output stream
        // Output       void    : The output stream is modified
        //                        to contain the start of a text flow

  {
  out << "<TextFlow					\n";
  out << " <TFTag `A'>					\n";
  }


void FM_TextFlow_End(ostream &out)

        // Input        ostr    : An output stream
        // Output       void    : The output stream is modified
        //                        to contain the end of a text flow

  { out << ">	# end of TextFlow			\n"; }


void FM_Paragraph_Set (ostream &out)

        // Input        ostr    : An output stream
        // Output       void    : The output stream is modified
        //                        to contain the start of a paragraph

  {
  out << " <Para					\n";
  out << "  <PgfTag `Body'>				\n";
  out << "  <ParaLine					\n";
  }


void FM_Paragraph_End(ostream &out, int ID)

        // Input        ostr    : An output stream
        // Output       void    : The output stream is modified
        //                        to contain the end of a paragraph

  {
  out << "   <Pen 15>					\n";
  out << "   <Fill 7>					\n";
  out << Gform( "   <AFrame %d>\n", ID);
  out << "  >						\n";
  out << " > # end of Para				\n";
  }


void FM_ParaText_End (ostream &out)
    // Create TextFlow with Frame
  {
  FM_TextFlow_Set(out);
  FM_Paragraph_Set(out);
  FM_Paragraph_End(out);
  FM_TextFlow_End(out);
  }


void FM_TextLine(ostream &out, int ID, double x, double y, char z,
                                  double size, int align, int angle)

	// Input	out       : output stream
	// 		ID        : Text group ID number (0 = no group)
	//		x	  : Text x-alignment coordinate
	//		y	  : Text y-alignment coordinate
	//		z	  : Character to be put in TextLine
	// 		size 	  : Font size in points
	// 		align     : Arrow on line (TRUE = yes, FALSE = no)
	// 		angle     : Angle flag (0=center, <0=Left, >0=Right)
	// Output	none      : Function is void.  Puts the commands
	//			    to produce a FrameMaker TextLine in MIF format
	// Note			  : Although MIF character format(s) can be specified
	//			    here it is left for user to do so within FM itself,
	//			    except for the font size.
	// Note			  : Additional generic object data can be included here
	//			    as specified in the Frame manual "MIF Reference"
	//			    such as color and pen pattern.  Not in currently

  {
  out << "  <TextLine \n";					// Start TextLine
  out << Gform( "    <GroupID %d>\n", ID);			// Set Text Group ID
  out << Gform("    <TLOrigin  %3.3f cm ", x);		// Specify alignment point
  out << Gform("%3.3f cm> \n", y);
  switch(align)						// Set alignment type
    {
    case 0:
    default:
        out << "    <TLAlignment Center > \n";
        break;
    case 1:
        out << "    <TLAlignment Right > \n";
        break;
    case 2:
        out << "    <TLAlignment Left > \n";
        break;
    }
  switch(angle)						 // Set text angle
    {
    case 0:
    default:
        out << "    <Angle 0 > \n";
        break;
    case 90:
        out << "    <Angle 90 > \n";
        break;
    case 180:
        out << "    <Angle 180 > \n";
        break;
    case 270:
        out << "    <Angle 270 > \n";
        break;
    }
  if(size)							// Set the font size
    {
    out << "    <Font \n"; 
    out << Gform("      <FSize  %3.1f pt> \n", size);
    out << "    > # end of Font \n"; 
    }
  out << "    <String `" << z << "'> \n"; 
  out << "  > # end of TextLine \n";				// End TextLine
  }


void FM_TextLine(ostream &out, int ID, int al, double x, double y, double z)

  {
  out << "  <TextLine \n";
  out << Gform("    <TLOrigin  %3.3f cm ", x);
  out << Gform("%3.3f cm> \n", y);
  switch(al)
      {
      case 0:
        out << "    <TLAlignment Center > \n";
        break;
      case 1:
        out << "    <TLAlignment Right > \n";
        break;
      case 2:
      default:
        out << "    <TLAlignment Left > \n";
        break;
      }
    out << Gform( "    <GroupID %d>\n", ID);
    out << "    <Angle 0> \n"; 
    out << "    <String `" << z << "'> \n"; 
    out << "  > # end of TextLine \n";
  }


void FM_TextLine(ostream &out, int ID, double x, double y, string text, 
                                            double size, int align, int angle)

	// Input	out       : output stream
	// 		ID        : Text group ID number (0 = no group)
	//		x	  : Text x-alignment coordinate
	//		y	  : Text y-alignment coordinate
	//		text	  : string to be put in TextLine
	// 		size 	  : Font size in points
	// 		arrow     : Arrow on line (TRUE = yes, FALSE = no)
	// 		angle     : Angle flag (0=center, <0=Left, >0=Right)
	// Output	none      : Function is void.  Puts the commands
	//			    to produce a FrameMaker TextLine in MIF format
	// Note			  : Although MIF character format(s) can be specified
	//			    here it is left for user to do so within FM itself,
	//			    except for the font size.
	// Note			  : Additional generic object data can be included here
	//			    as specified in the Frame manual "MIF Reference"
	//			    such as color and pen pattern.  Not in currently

  {
  out << "  <TextLine \n";					// Start TextLine
  out << Gform( "    <GroupID %d>\n", ID);			// Set Text Group ID
  out << Gform("    <TLOrigin  %3.3f cm ", x);	   	// Specify alignment point
  out << Gform("%3.3f cm> \n", y);				// Specify alignment point
  switch(align)						// Set alignment type
      {
      case 0:
      default:
        out << "    <TLAlignment Center > \n"; break;
      case 1:
        out << "    <TLAlignment Right > \n";  break;
      case 2:
        out << "    <TLAlignment Left > \n";   break;
      }
    switch(angle)						 // Set text angle
      {
      case 0:
      default:
        out << "    <Angle 0 > \n";
        break;
      case 90:
        out << "    <Angle 90 > \n";
        break;
      case 180:
        out << "    <Angle 180 > \n";
        break;
      case 270:
        out << "    <Angle 270 > \n";
        break;
      }
    if(size)							// Set the font size
      {
      out << "    <Font \n"; 
      out << Gform("      <FSize  %3.1f pt> \n", size);
      out << "    > # end of Font \n"; 
      }
    out << "    <String `" << text << "'> \n"; 
    out << "  > # end of TextLine \n";				// End TextLine
  }

// ____________________________________________________________________________
// D                    FRAMEMAKER MIF TABLE CONSTUCTS
// ____________________________________________________________________________


void FM_Tbl_Begin(ostream &out)

        // Input        ostr    : An output stream
        // Output       void    : The output stream is modified
        //                        to contain the start of a table

  {
  out << "<Tbls \n";
  out << " <Tbl \n";
  out << " <TblID 1>\n";
  }


void FM_Tbl_End(ostream &out)

        // Input        ostr    : An output stream
        // Output       void    : The output stream is modified
        //                        to contain the end of a table

  {
  out << "> # end of Tbl\n";
  out << "> # end of Tbls\n";
  }


void FM_TblBody_Begin(ostream &out)

        // Input        ostr    : An output stream
        // Output       void    : The output stream is modified
        //                        to contain a table body start

  { out << " <TblH \n"; }


void FM_TblBody_End(ostream &out)

        // Input        ostr    : An output stream
        // Output       void    : The output stream is modified
        //                        to contain a table body end

  { out << " > # end of TblBody\n"; }


void FM_Tbl_Title(ostream &out)

        // Input        ostr    : An output stream
        // Output       void    : The output stream is modified
        //                        to contain a table title

  {
  out << " <TblTitleContent \n";
  out << "  <Para \n";
  out << "   <PgfTag `TableTitle'>\n";
  out << "   <PgfNumstring `Table 1: '>\n";
  out << "   <ParaLine \n";
  out << "   >\n";
  out << "  > # end of Para\n";
  out << " > # end of TblTitleContent\n";
  }


// ______________________________________________________________________
// E                 FRAMEMAKER MIF GRAPIC OBJECTS 
// ______________________________________________________________________


void FM_Ellipse(ostream &out, double x, double y, double rx, double ry,
	             int GID, int fill, int color, int pen, double width)

	// Input	out       : output stream
	// 		group     : Line group ID number (0 = no group)
	// 		arrow     : Arrow on line (TRUE = yes, FALSE = no)
	// 		width     : Line width in points
	//		fill      : Ellipse fill pattern (7=solid white)
	//		x	  : Ellipse x coordinate
	//		y	  : Ellipse y coordinate
	//		rx	  : Ellipse width (cm)
	//		ry	  : Ellipse height (cm)
	// Output	none      : Function is void.  Puts the commands
	//			    to produce a FrameMaker Ellipse in MIF
	//			    format.

    {
    if(color) fill = 0;
    out << "  <Ellipse \n";
    if(GID) out << Gform( "    <GroupID %d>\n", GID);		// Ellipse Group ID
    if(pen) out << Gform( "    <Pen %d>\n", pen);		// Pen Pattern
    out << Gform( "    <Fill %d>\n", fill);			// Fill Pattern
    if(width) out << Gform( "    <PenWidth %d>\n", width);	// Edge Thichness
    if(color) out << Gform( "    <Separation %d>\n", color);	// Spot Color (0-7)
    out << Gform("    <BRect  %3.3f cm ", x-rx);			 // Location, Size
    out << Gform("%3.3f cm %", y-rx);
    out << Gform("%3.3f cm > \n", 2*rx);
    out << Gform("%3.3f cm> \n", 2*ry);
    out << "  > # end of Ellipse \n";
    }


void FM_Line (ostream &out, int group, int arrow, double width,
                            double x1, double y1,double x2, double y2, int pen)

	// Input	out       : output stream
	// 		group     : Line group ID number (0 = no group)
	// 		arrow     : Arrow on line (TRUE = yes, FALSE = no)
	// 		width     : Line width in points
	// 		x1,y1     : Initial coordinates
	// 		x2,y2     : Final coordinates
	// 		pen       : Pen type
	// Output	none      : Function is void.  Puts the commands
	//			    to produce a FrameMaker Line in MIF
	//			    format.  Line is an arrow from (x1,y1) to
	//			    (x2,y2), the coordinates relative to the
	//			    current Frame.

  {
  out << "  <PolyLine\n";
  if (width)
    out << "   <PenWidth  "<<width<<" pt>\n";
  if (group)
    out << "   <GroupID "<<group<<">\n";
  if (arrow > 0)
    {
      out << "   <HeadCap ArrowHead >\n";
      out << "   <TailCap Round >\n";
      out << "   <ArrowStyle\n";
      out << "    <TipAngle 16>\n";
      out << "    <BaseAngle 90>\n";
      out << "    <Length  12.0 pt>\n";
      out << "    <HeadType Filled >\n";
      out << "    <ScaleHead Yes >\n";
      out << "    <ScaleFactor  0.25 pt>\n";
      out << "   > # end of ArrowStyle\n";
    }
  else if(arrow == 0)
    {
    out << "   <HeadCap Round >\n";
    out << "   <TailCap Round >\n";
    }
  out << Gform( "    <Pen %d>\n", pen);
  out << "   <NumPoints 2>\n";
  out << Gform("   <Point %3.3f cm ", x1);
  out << Gform("%3.3f cm>\n", y1);
  out << Gform("   <Point %3.3f cm ", x2);
  out << Gform("%3.3f cm>\n", y2);
  out << "  > # end of PolyLine\n";
  }


void FM_PolyLine(ostream &out, const row_vector& vx, int ID, int fill,
                                               int points, int pen, int width)

	// Input	out       : output stream
	// 		vx        : vector of x,y values (Re, Im)
	// 		ID        : PolyLine ID number
	// 		fill      : PolyLine fill type
	// 		points    : Number of points in PolyLine
	// 		pen       : Pen thickness
	// 		width     : Pen width
	// Output	none      : Function is void.  Puts the commands
	//			    to produce a FrameMaker PolyLine.

  {
  out << "  <PolyLine\n"; 
  out << Gform( "    <GroupID %d>\n", ID);
  out << Gform( "    <Pen %d>\n", pen);
  out << Gform( "    <PenWidth %d>\n", width);
  out << Gform( "    <Fill %d>\n", fill);
  out << Gform( "    <NumPoints %d>\n", points);
  for(int k=0; k<points; k++)
    {
    out << Gform("    <Point %3.3f cm ", vx.getRe(k));
    out << Gform("%3.3f cm>\n", vx.getIm(k));
    }
  out << "    > # end of PolyLine                   \n";
  }


void FM_Rectangle(ostream &out, int ID,
                              double x, double y, double width, double height)

	// Input	out       : output stream
	// 		ID        : Rectangle ID number
	//		x	  : Rectangle x coordinate
	//		y	  : Rectangle y coordinate
	//		width	  : Rectangle width
	//		height	  : Rectangle height
	// Output	none      : Function is void.  Puts the commands
	//			    to produce a FrameMaker Rectangle.

  {
  out << "  <Rectangle \n";
  out << Gform( "    <GroupID %d>\n", ID);
  out << Gform("    <BRect  %3.3f cm ", x);
  out << Gform("%3.3f cm ", y);
  out << Gform("%3.3f cm ", width);
  out << Gform("%3.3f cm> \n", height);
  out << "  > # end of Rectangle \n";
  }


void FM_Polygon (ostream &out, int ID, double x, double y,
                                               double rx, int sides, int fill)

	// Input	out       : output stream
	// 		ID        : Polygon ID number
	//		x	  : Polygon x coordinate
	//		y	  : Polygon y coordinate
	//		rx	  : Polygon radius
	//		sides     : Polygon sides
	//		fill      : Polygon fill (default to solid white)
	// Output	none      : Function is void.  Puts the commands
	//			    to produce a FrameMaker Rectangle.
	// Note			  : The maximum allowed is an octagon
	//			    as set in this function by "maxsides"

  {
  static int maxsides = 8;
  if((sides < -3) || ((sides>0) && (sides <3)) || (sides>maxsides))
    sides = 0; 
  if(sides >0)			// Output a polygon of "sides" sides
    {
    double xp, yp, theta, phi;
    out << "  <Polygon\n"; 
    out << Gform( "    <GroupID %d>\n", ID);
    out << Gform( "    <NumPoints %d>\n", sides);
    out << Gform( "    <Fill %d>\n", fill);
    for(int i=0; i< sides; i++)
      {
      phi = PI/2;		// Odd number sides, a vertice at 90
      if(sides%2 == 0)		// Even number sides, vertice off 90
        phi -= PI/sides;
      theta = (2*PI*i)/sides;
      xp = rx*cos(theta+phi);
      yp = rx*sin(theta+phi);
      out << Gform("    <Point %3.3f cm ", x-xp);
      out << Gform("%3.3f cm>\n", y-yp);
      }
    out << "    > # end of Polygon \n";
    }
  else if(sides ==0)		// Output a circle. Coordinates are
    {				// Top, Left, Height, Width
    out << "  <Ellipse \n";
    out << Gform( "    <GroupID %d>\n", ID);
    out << Gform( "    <Fill %d>\n", fill);
    out << Gform("    <BRect  %3.3f cm ", x-rx);
    out << Gform("%3.3f cm ", y-rx);
    out << Gform("%3.3f cm ", 2*rx);
    out << Gform("%3.3f cm> \n", 2*rx);
    out << "  > # end of Ellipse \n";
    }
  else
    {
    double rt2=0.70710678;
    switch(sides)
      {
      case -1:					// +
        FM_Line(out,ID,-1,1.0, x-rx, y, x+rx, y);
        FM_Line(out,ID,-1,1.0, x, y-rx, x, y+rx);
        break;
      case -2:					// X's
        FM_Line(out,ID,-1,1.0, x-rt2*rx, y-rt2*rx, x+rt2*rx, y+rt2*rx);
        FM_Line(out,ID,-1,1.0, x-rt2*rx, y+rt2*rx, x+rt2*rx, y-rt2*rx);
        break;
      case -3:					// *'s
      default:
        FM_Line(out,ID,-1,1.0, x-rx, y, x+rx, y);
        FM_Line(out,ID,-1,1.0, x, y-rx, x, y+rx);
        FM_Line(out,ID,-1,1.0, x-rt2*rx, y-rt2*rx, x+rt2*rx, y+rt2*rx);
        FM_Line(out,ID,-1,1.0, x-rt2*rx, y+rt2*rx, x+rt2*rx, y-rt2*rx);
        break;
      }
    }
  return;
  }

#endif 						// FrameMakerM.cc
